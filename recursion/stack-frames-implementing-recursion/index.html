<p>Suppose that instead of concatenating the result of the recursive call
to <code>to_string</code> with the string from <code>CHAR_FROM_INT</code>, we modified our
algorithm to push the strings onto a stack prior to making the recursive
call. The code for this modified algorithm might look like:</p>
  <pre><code class="language-python">CHAR_FROM_INT <span class="token operator">=</span> <span class="token string">'0123456789ABCDEF'</span>

<span class="token keyword">def</span> <span class="token function">to_string</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span>base<span class="token punctuation">)</span><span class="token punctuation">:</span>
    stack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token keyword">while</span> n <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> n <span class="token operator">&lt;</span> base<span class="token punctuation">:</span>
            stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>CHAR_FROM_INT<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>CHAR_FROM_INT<span class="token punctuation">[</span>n <span class="token operator">%</span> base<span class="token punctuation">]</span><span class="token punctuation">)</span>
        n <span class="token operator">=</span> n <span class="token operator">//</span> base
    result <span class="token operator">=</span> <span class="token string">''</span>
    <span class="token keyword">while</span> stack<span class="token punctuation">:</span>
        result <span class="token operator">=</span> result <span class="token operator">+</span> stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> result

to_string<span class="token punctuation">(</span><span class="token number">1453</span><span class="token punctuation">,</span><span class="token number">16</span><span class="token punctuation">)</span>  <span class="token comment"># => 5AD</span>
</code></pre>


<p>Each time we make a call to <code>to_string</code>, we push a character on the stack.
Returning to the previous example we can see that after the fourth call
to <code>to_string</code> the stack would look the diagram below.
Notice that now we can simply pop the characters off the stack and
concatenate them into the final result, <code>&#39;1010&#39;</code>.</p>
<p>
  <figure>
    <img src="figures/recursion-stack.png" alt="Strings placed on the stack during
conversion">
    <figcaption>Strings placed on the stack during
conversion</figcaption>
  </figure></p>
<p>The previous example gives us some insight into how Python implements a
recursive function call. When a function is called in Python, a <strong>stack
frame</strong> is allocated to handle the local variables of the function. When
the function returns, the return value is left on top of the stack for
the calling function to access. The diagram below
illustrates the call stack after the return statement.</p>
<p>
  <figure>
    <img src="figures/new-call-stack.png" alt="Call stack generated from
to_string(10, 2)">
    <figcaption>Call stack generated from
to_string(10, 2)</figcaption>
  </figure></p>
<p>Notice that the call to <code>to_string(2 // 2, 2)</code> leaves a return value of <code>&#39;1&#39;</code>
on the stack. This return value is then used in place of the function
call (<code>to_string(1,2)</code>) in the expression <code>&#39;1&#39; + CHAR_FROM_INT[2 % 2]</code>, which
will leave the string <code>&#39;10&#39;</code> on the top of the stack. In this way, the
Python call stack takes the place of the stack we used explicitly in our algorithm above. In our list summing example, you can
think of the return value on the stack taking the place of an
accumulator variable.</p>
<p>The stack frames also provide a scope for the variables used by the
function. Even though we are calling the same function over and over,
each call creates a new scope for the variables that are local to the
function.</p>
